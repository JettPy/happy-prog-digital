# Наследование классов

# Мы уже познакомились с одной из концепций ООП - инкапсуляцией. Сегодня изучим еще одну - наследование.
# Название наследование уже говорит само за себя. Как дети наследуют черты своих родителей, так и дочерние классы
# наследуют поля и методы своих родительских классов.

# К примеру у нас есть некий класс A:
class A:
    def __init__(self):
        self.a = 5  # у него есть поле а

    def print_a(self):  # есть метод вывода поля а
        print(f'a: {self.a}')

    def print_fields(self):  # и есть метод вывода всех полей
        print('Поля класса:')
        print(f'a: {self.a}')


# Для того чтобы наследовать класс, используют запись такого вида:
# class <дочерний класс> (<родительский класс>):
#     <тело класса>

# Создадим дочерний класс B:
class B (A):
    def __init__(self):
        # При вызове конструктора дочернего класса, нам необходимо внутри вызвать конструктор родительского класса.
        # Для того чтобы обратиться к родительскому классу используется команда super():
        super().__init__()  # тут вызываем конструктор A для инициализации поля а
        self.b = 2  # у конструктора есть свое поле b

    def print_b(self):  # есть метод вывода поля b
        print(f'b: {self.b}')

    # Пересоздадим метод вывода всех полей, но этот метод уже существует в родительском классе.
    # В таком случае этот метод будет перезаписан и для объектов класса B будет исполняться именно этот метод,
    # а для объектов класса A тот что выше.
    def print_fields(self):
        print('Поля класса:')
        print(f'a: {self.a}')
        print(f'b: {self.b}')

    # def print_fields(self):
    #     super().print_fields()  # или возможна такая запись, через вызов родительского метода
    #     print(f'b: {self.b}')


# Вот что у нас получилось:
object_a = A()
print('Методы объекта класса A')
object_a.print_a()
object_a.print_fields()
object_b = B()
print('Методы объекта класса B')
object_b.print_a()
object_b.print_b()
object_b.print_fields()


# Рассмотрим наследование на примере взаимодействия юнитов вымышленной игры

# Создадим класс Unit:
class Unit:
    # кстати все классы в python по умолчанию наследуются от базового класса object:
    # class Unit (object):

    # Создадим конструктор юниту. На вход он будет принимать имя и количество жизней
    # в python можно уточнять тип аргумента функции и ее значение по умолчанию:
    # <имя> - обычная передача обязательного параметра, любого типа
    # <имя>: <тип> - передача обязательного параметра, с определенным типом
    # <имя>=<значение> - передача необязательного параметра любого типа, если он не передан, примет указанное значение
    # <имя>: <тип> = <значение> - передача необязательного параметра, с определенным типом. Объединяет выше указанное
    def __init__(self, name: str, hp=100):
        self.hp = hp
        self.name = name

    def who(self):  # определяем метод, которая будет говорить кто этот юнит
        print(f'Я юнит по имени {self.name}')

    def get_damage(self, dp: int):  # метод получения урона, будет вызываться когда юнит получает урон
        self.hp -= dp  # отнимаем переданное количество жизней
        print(f'{self.name} ранен. Теперь у него {self.hp} жизней')

    def get_heal(self, tp: int):  # метод получения лечения, будет вызываться когда юнита лечат
        self.hp += tp  # добавляем переданное количество жизней
        print(f'{self.name} подлечился. Теперь у него {self.hp} жизней')


# Создадим дочерний класс воин:
class Warrior (Unit):
    # В конструкторе помимо базовых параметров юнита будем передавать ему его урон (damage points).
    # Воин немножечко выносливее обычного юнита, поэтому его количество жизней чуть больше
    def __init__(self, name, hp=120, dp=20):
        super().__init__(name, hp)  # вызываем родительский конструктор
        self.dp = dp

    def who(self):  # переопределим метод для воина
        print(f'Я воин по имени {self.name}')

    def hit(self, unit: Unit):  # добавим войну метод для нанесения урона.
        print(f'Воин {self.name} атакует!')
        unit.get_damage(self.dp)  # отнимаем здоровье юнита
    # Как можно заметить мы передаем ссылку на объект класса Unit. Так как все наши персонажи будут наследоваться от
    # класса Unit то мы можем использовать родительский класс как тип. Это очень удобно, ведь нам неважно с кем мы
    # будем взаимодействовать: юнит, воин, доктор, писатель или торговец. Это все не важно, главное, что они все
    # способны вызывать функцию get_damage и получать урон


# И создадим еще один класс доктора:
class Doctor (Unit):
    # По аналогии с классом воина, наш доктор имеет силу лечения (treatment points), но выносливость у него поменьше
    def __init__(self, name, hp=80, tp=30):
        super().__init__(name, hp)
        self.tp = tp

    def who(self):  # опять же переопределяем этот метод
        print(f'Я доктор по имени {self.name}')

    def heal(self, unit: Unit):  # создадим метод для лечения, и нам тоже не важно кого мы лечим
        print(f'Доктор {self.name} лечит')
        unit.get_heal(self.tp)  # лечим юнита


# А теперь создадим эти объекты и посмотрим как они взаимодействуют
worker = Unit('Рабочий')
doctor = Doctor('Целитель')
warrior = Warrior('Викинг')

worker.who()
warrior.who()
warrior.hit(worker)
doctor.who()
doctor.heal(worker)

# Может показаться что юнит очень абстрактное понятие. Да это так.
# И тут мы сталкиваемся с еще одной концепцией ООП - абстракцией (хотя многие источники не считают это концепцией).
# Иногда мы сталкиваемся с тем что наши классы имеют одинаковые методы, но реализация их разная.
# Например, самолет передвигается, но по воздуху, а машина передвигается по земле. Тогда мы можем создать родительский
# класс транспорта и определить этот метод там. Но какая реализация будет заложена в этот метод, зависит от наследника.
# Такие методы называются абстрактными, а классы содержащие такие методы - абстрактные классы.
# В силу того, что у нас есть нереализованные методы, мы не можем создавать объекты абстракты классов,
# а только их наследников.


# Перепишем наш класс Unit, сделав его абстрактным:

# В Python отсутствует встроенная поддержка абстрактных классов, для этого используется модуль abc (Abstract Base Class)
from abc import ABC, abstractmethod


class Unit (ABC):  # ABC - говорит о том что этот класс теперь абстрактный
    def __init__(self, name: str, hp=100):
        self.hp = hp
        self.name = name

    # абстрактный метод, который будет необходимо переопределять для каждого подкласса
    @abstractmethod  # @abstractmethod - декоратор, который делает наш метод абстрактным
    def who(self):  # теперь узнать что именно это за юнит мы можем узнать только в наследнике
        pass

    def get_damage(self, dp: int):
        self.hp -= dp
        print(f'{self.name} ранен. Теперь у него {self.hp} жизней')

    def get_heal(self, tp: int):
        self.hp += tp
        print(f'{self.name} подлечился. Теперь у него {self.hp} жизней')


class Warrior (Unit):
    def __init__(self, name, hp=120, dp=20):
        super().__init__(name, hp)
        self.dp = dp

    def who(self):
        print(f'Я воин по имени {self.name}')

    def hit(self, unit: Unit):
        print(f'Воин {self.name} атакует!')
        unit.get_damage(self.dp)


class Doctor (Unit):
    def __init__(self, name, hp=80, tp=30):
        super().__init__(name, hp)
        self.tp = tp

    def who(self):
        print(f'Я доктор по имени {self.name}')

    def heal(self, unit: Unit):
        print(f'Доктор {self.name} лечит')
        unit.get_heal(self.tp)


try:  # попробуем создать объект класса Unit
    worker = Unit('Рабочий')
except TypeError:  # теперь мы получаем ошибку, потому что нельзя создавать объекты абстрактных классов
    print('Нельзя создать объект абстрактного класса!')
doctor = Doctor('Целитель')
warrior = Warrior('Викинг')

warrior.who()
warrior.hit(doctor)
doctor.who()
doctor.heal(warrior)

# Классы и ООП

# Создадим обычную переменную типа int и выведем ее тип в консоль:
a = 5
print(type(a))  # Вывод: <class 'int'>

# Дело в том что Python - это объектно-ориентированный язык, и в нем нет простых типов. Все есть классы.

# Объектно-ориентированное программирование - это подход, при котором программа рассматривается как набор объектов,
# взаимодействующих друг с другом. У каждого есть свойства и поведение.
# ООП ускоряет написание кода и делает его более читаемым.

# Опишем дом:
address = "Можайское ш. д.1"
doors = 3
windows = 5

# Мы создали 3 отдельных переменных, но мы можем их объединить в одну структуру (класс):


class House:
    address = "Можайское ш. д.1"
    doors = 3
    windows = 5


# Классы - это чертежи, а то что по ним создается это объекты.
# Теперь мы можем создать переменную класса (объект), где все эти переменные объеденины (поля):
house = House()
print(f'Адрес: {house.address}, количество дверей: {house.doors}, количество окон: {house.windows}')

# Мы можем менять значения полей и добавлять новые поля:
house.address = 'Вокзальная ул. д. 6'
house.color = 'белый'
print(f'Адрес: {house.address}, количество дверей: {house.doors}, количество окон: {house.windows}, цвет: {house.color}')

# Значения полей нашего объекта при создании всегда одинаковые, а хотелось бы что бы была возможность передавать такие
# значения которые мы сами захотим. Для этого используются конструкторы класса.

# Конструктор класса это функция внутри класса (метод) которая вызывается при создании объекта.
# И в языке python для него есть зарезервированное имя: __init__.
# init - сокращение от initialization - "инициализация", грубо говоря создание. Два подчеркивания в начале и в конце
# означают что это специальная "магическая" функция заранее определенная языком python.
# Далее, как и в обычной функции мы перечисляем аргументы функции,
# но первый параметр почти всегда self - о нем поговорим ниже.


class House:
    def __init__(self, address_arg, doors_arg, windows_arg):
        address = address_arg
        doors = doors_arg
        windows = windows_arg


house = House("Можайское ш. д.1", 3, 5)
try:
    print(f'Адрес: {house.address}, количество дверей: {house.doors}, количество окон: {house.windows}')
except AttributeError as error:
    print('Ой-йой, ошибка. Пишет:')
    print(error)

# У нашего класса нет полей address, doors, windows. Связано это с областью видимости функций в python.
# После выполнения конструктора переменные были удалены из памяти. Необходимо привязать наши переменные к классу.
# Для этого используется первый аргумент - self.
# self - это ссылка на сам объект. Как раз в него мы и запишем наши поля:


class House:
    def __init__(self, address_arg, doors_arg, windows_arg):
        self.address = address_arg
        self.doors = doors_arg
        self.windows = windows_arg


# Теперь мы можем создавать объекты класса House с разными значениями полей, ура!
house = House("Можайское ш. д.1", 3, 5)
house2 = House("Вокзальная ул. д. 6", 10, 26)
print(f'Адрес: {house.address}, количество дверей: {house.doors}, количество окон: {house.windows}')
print(f'Адрес: {house2.address}, количество дверей: {house2.doors}, количество окон: {house2.windows}')

# Одна из 4 концепций ООП: инкапсуляция. Инкапсуляция с английского "in capsule" - "в капсуле".
# Смысл в том что мы можем давать разный доступ к содержимому класса.
# Существует 3 уровня доступа:
# public - публичный - видно всем и везде
# private - приватный - доступ только в пределах класса
# protected - защищенный - о нем поговорим позже, пока считайте что он такой же, как private.

# Для того что бы обозначить уровень доступа перед именем поля или метода ставится символ нижнего подчеркивания:


class Example:
    def __init__(self):
        self.public = 'публичное поле'
        self._protected = 'защищенное поле'
        self.__private = 'приватное поле'


a = Example()
print(a.public)  # Все окей
try:
    print(a._protected)  # Вроде все хорошо, ошибки нет, переменная выводиться, но python ругается:
except Exception:                                        #  "Access to a protected member _protected of a class"
    print('Ошибка! Поле защищенное!')
try:
    print(a.__private)  # А здесь уже ошибка, нельзя обращаться к приватной переменной
except Exception:
    print('Ошибка! Поле приватное!')

# Python не поддерживает инкапсуляцию как другие объектно-ориентированные языки,
# но понимать как работают модификаторы доступа нужно.

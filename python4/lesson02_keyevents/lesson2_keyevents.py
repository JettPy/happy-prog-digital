# Импортируем библиотеку pygame
import pygame

# Задаем размеры поля в пикселях и количество кадров в секунду
WIDTH = 800
HEIGHT = 600
FPS = 60

# Задаем цвет фона и цвет для объекта, которым мы будем управлять
LIGHT_GREEN = (196, 240, 129)
RED = (199, 71, 16)

# Инициализируем pygame
pygame.init()
# Создаем объект экрана и задаем ему размер
screen = pygame.display.set_mode((WIDTH, HEIGHT))
# Создаем объект часов для задания времени обработки кадра
clock = pygame.time.Clock()

# Создаем класс на основе спрайта из pygame.
# Спрайт - это графический объект на экране имеющий свои свойства и поведение


# Пример такого спрайта будет наш игровой объект:
class Player (pygame.sprite.Sprite):
    def __init__(self):
        # Первым делом необходимо проинициализировать конструктор родителя
        super().__init__()
        # Зададим поле image и укажем ему, что он является поверхностью размером 32 на 32 пикселя, красного цвета
        self.image = pygame.Surface((32, 32))
        self.image.fill(RED)
        # Далее создадим поле rect, которое будет являться неким хит боксом нашего объекта image
        self.rect = self.image.get_rect()
        # Зададим поле v которое будет отвечать за скорости игрока по x и по y
        self.v = [0, 0]

    # А также создадим метод update, который будет обновлять положение игрока
    def update(self):
        # Для изменения координат используется метод move_ip.
        # Этот метод принимает смещение координат по осям x и y относительно текущей точки.
        # Этот метод не создает новый спрайт, а перемещает старый (in place)
        # Оператор звездочка (*) перед списком это оператор распаковки, он достает значения из списка
        # и раскладывает значения по аргументам метода.
        self.rect.move_ip(*self.v)


# Создаем объект нашего игрока
player = Player()
# Переменная для игрового цикла
isRunning = True
while isRunning:
    # Метод clock.tick возвращает количество миллисекунд для обновления экрана
    t = clock.tick(FPS)
    screen.fill(LIGHT_GREEN)
    for event in pygame.event.get():
        # Обработка события выхода
        if event.type == pygame.QUIT:
            isRunning = False
        # Обработка события нажатия клавиши
        # Мы создавали класс игрока и добавляли поля скорости для того, что бы
        # можно было задать плавное перемещение объекта по экрану.
        # Если кнопка (W, A, S, D) была нажата, то задаем соответсвующую скорость
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_w:
                player.v[1] = -.5 * t
            elif event.key == pygame.K_s:
                player.v[1] = .5 * t
            elif event.key == pygame.K_a:
                player.v[0] = -.5 * t
            elif event.key == pygame.K_d:
                player.v[0] = .5 * t
        # А когда мы отжимаем клавишу, то выставляем соответсвующую скорость (по вертикали или горизонтали) в 0
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_w or event.key == pygame.K_s:
                player.v[1] = 0
            elif event.key == pygame.K_a or event.key == pygame.K_d:
                player.v[0] = 0
    # Обязательно после проверки событий необходимо обновить спрайт игрока
    player.update()
    # Метод blit нужен для отображения спрайта на экране,
    # этот метод принимает само изображение спрайта и его координаты (хит бокс)
    screen.blit(player.image, player.rect)
    # И в конце цикла обновляем экран
    pygame.display.update()
pygame.quit()

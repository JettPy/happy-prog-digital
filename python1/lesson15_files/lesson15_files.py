# импорт и экспорт

# Мы можем импортировать (взять функции и переменные) из других файлов
# Мы уже сталкивались с этой командой, рассмотрим подробнее:
# import <название модуля>

import time  # подключаем библиотеку для работы со временем

# Мы подключили весь модуль, для доступа к его содержимому надо обращаться через название модуля:
# <название модуля>.<функция из модуля>
current_time = time.ctime()  # Обратились к функции ctime модуля time
print(current_time)  # Выводит текущую дату и время

# Есть другой способ импортировать только конкретные элементы модуля:
# from <название модуля> import <необходимые функции>

from math import sqrt, ceil # подключаем только функции квадратного корня и округления в потолок

# Так как мы импортируем только определенные функции, можно обратиться сразу к ним по названию без названия модуля:

print(sqrt(121))  # Вывод: 11.0
print(ceil(10.6))  # Вывод: 11

# Так же можно писать свои модули. Вы просто создаете python файл с функциями или переменными внутри.
# Например, есть файл my_utils.py и в нем функции hello() и min().
# Тогда для получения функции hello:
from my_utils import hello

hello() # Вывод: Hello, world!

# Так же можно импортировать все элементы модуля с помощью *,
# тогда можно обращаться ко всем элементам без указания названия модуля:
from my_utils import *  # но этот способ не безопасен так как он может перезаписать существующие функции.

# Например, в нашем случае мы перезапишем функцию нахождения минимума min():

a = [2, 4, 1, 7, 5]
print(min(a))  # Вывод: Я минимум (функция была изменена)

# Работа с файлами

# В python, как и во многих языках можно читать и писать текст в файлы.
# Для открытия файла используется функция open:
# <имя переменной файла> = open(<имя файла с расширением>, <режим работы>)
# режим работы - это для чего мы открываем файл:
# r - для чтения в текстовом виде
# rb - для чтения в двоичном виде (читает по байтам)
# w - для записи в файл
# wb - для записи в файл в двоичном виде (запись по байтам)

# Важно знать что если открыть несуществующий файл на чтение то будет ошибка.
# А если открыть несуществующий файл на запись, то он просто его создаст.

file = open('input.txt', 'r')

# Метод readlines() - читает все строки и возвращает список строк
text = file.readlines()
print(text)  # Вывод: ['qwerty\n', '12345\n', 'uiop\n']

# Метод close() - закрывает файл, его следует делать, что бы файл не пострадал при ошибке и не тратил ресурсы памяти
file.close()

# Внутри file тоже есть подобие курсора, поэтому если содержимое файла закончилось, читать будет уже нечего.
file = open('input.txt', 'r')
# Другой метод это read(<количество символов>)
# Он читает заданное количество символов, если число не задано, то читает все:
print(file.read(5))  # Вывод: qwert
print(file.read())  # Вывод: y\n12345\nuiop
file.close()

file = open('input.txt', 'r')
# И так же можно читать по строкам:
for line in file:
    print(line)  # прочитает сначала qwerty\n, потом 12345\n, и наконец uiop\n
file.close()

file = open('output.txt', 'w')
# Для записи в файл можно использовать writelines(<список строк>) для записи сразу нескольких строк
file.writelines(text)

# Или можно записывать поэлементно методом write():
for element in [123, 3.14, True, 'hello']:
    # Стоит заметить что метод write записывает только строки и не имеет переноса строки, поэтому мы его добавляем сами:
    file.write(str(element) + '\n')
file.close()

# Кортежи tuple

# Кортежи очень похожи на списки.
# Кортеж tuple - простыми словами это неизменяемые списки.
# После создания таких списков мы больше не сможем менять их значения.

# Создать пустой кортеж можно несколькими способами:
tuple_a = tuple()
tuple_b = ()
print(f'tuple_1: {type(tuple_a)}, tuple_2: {type(tuple_b)}')
# вывод: tuple_1: <class 'tuple'>, tuple_2: <class 'tuple'>

# Создать кортежи с какими-то значениями можно так:
tuple_a = (1, 2, 3)
tuple_b = 3, 4, 5  # как раз когда мы в функциях пишем return a, b, c функция возвращает кортеж
print(tuple_a)  # вывод: (1, 2, 3)
print(tuple_b)  # вывод: (3, 4, 5)

# Для создания кортежа из одного элемента достаточно после значения поставить запятую,
# тогда python будет считать это как кортеж:
a = 5
print(f'a: {type(a)}')  # вывод: a: <class 'int'>
a = 5,  # или a = (5,)
print(f'a: {type(a)}')  # вывод: a: <class 'tuple'>

# Можно создать кортеж символов на основе строки:
hello = tuple('Hello, world!')
print(hello)  # вывод: ('H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!')
# или на основе списка:
tuple_from_list = tuple([1, 3.14, 'abc', True])
print(tuple_from_list)  # вывод: (1, 3.14, 'abc', True)

# Как и в списках доступ к элементам осуществляется через индексы
print(tuple_from_list[1])  # вывод: 3.14
print(tuple_from_list[-2])  # вывод: abc
# Что бы узнать длину кортежа можно использовать функцию len:
print(len(tuple_from_list))  # вывод: 4

#  Можно использовать срезы:
float_tuple = (1.1, 0.5, 45.5, 33.33, 9.12, 3.14, 2.73)
print(float_tuple[0:3])  # вывод: (1.1, 0.5, 45.5)

# Можно распаковать (разбивать на переменные) содержимое кортежей:
a, b, c = (5, 6, 7)
print(f'a = {a}, b = {b}, c = {c}')  # вывод: a = 5, b = 6, c = 7
# Как и списки кортежи можно распаковывать частично (и с начала, и с конца)
a, b, *other, z = (1, 2, 3, 4, 5)
print(a, b, z, other)  # вывод: 1 2 5 [3, 4]

# Кортежи можно сравнивать как списки
print((1, 2, 3) > (1, 2))  # вывод: True

# Кортежи имеют всего два метода
# 1) метод count: считает количество вхождений элемента в кортеже:
names = ('Петя', 'Ваня', 'Саша', 'Петя', 'Максим')
n = names.count('Петя')
print(f'Петя встречается {n} раза')  # вывод: Петя встречается 2 раза
# 2) метод index: позволяет получить индекс элемента, если элемента нет вызывает ошибку ValueError:
rom = ('I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X')
print(rom.index('X'))  # вывод: 9

# А в чем преимущества кортежей?
# Кортежи занимают меньше места в памяти и поиск в них происходит быстрее.
a = (1, 2, 3, 4, 5, 6)
b = [1, 2, 3, 4, 5, 6]
print(a.__sizeof__())  # вывод: 72
print(b.__sizeof__())  # вывод: 88


# Продолжим рассматривать алгоритмы, сегодня рассмотрим алгоритм бинарного поиска.
# Для его работы требуется отсортированный список. В ходе работы алгоритм вычисляет серединный элемент и сравнивает его
# с искомым значением. Если значение больше, то будем проверять правую часть, если меньше, то левую.
# Если значение найдено, то мы возвращаем его индекс в списке, если же нет, возвращаем -1

# Алгоритм бинарного поиска:
def bin_search(array, value):
    start = 0  # индекс самого левого элемента
    end = len(array) - 1  # индекс самого правого элемента
    middle = len(array) // 2  # вычисляем середину
    while array[middle] != value and start <= end:  # цикл поиска
        if value > array[middle]:  # если значение больше серединного
            start = middle + 1  # то левая граница теперь равна серединному элементу плюс один
        else:  # если значение меньше серединного
            end = middle - 1  # то правая граница теперь равна серединному элементу минус один
        middle = (start + end) // 2  # заново находим серединный элемент
    return -1 if start > end else middle  # возвращаем -1, если элемент не найден или его индекс, если найден


list_of_nums = [1, 5, 10, 24, 25, 26, 30, 31, 34, 39, 40, 40, 46, 61, 70, 75, 81, 88, 94, 95]
print(bin_search(list_of_nums, 75))  # вывод: 15
print(bin_search(list_of_nums, 41))  # вывод: -1. элемента нет
# Оценка алгоритма бинарного поиска:
# По времени: с каждым шагом, диапазон поиска уменьшается вдвое, что эквивалентно функции O(log n)
# По памяти: алгоритм сортировки не создает дополнительные списки для хранения элементов, по этому память всегда
# выделяется одинаковая, то есть O(1).

# Задание 1:
# Дети играют в игры на аркадном автомате. Программа записывает количество набранных очков и имя игрока.
# Вывести топ 3 игроков

score_table = []
n = int(input('n > '))
for _ in range(n):
    score, name = input('score & name> ').split()
    score = int(score)
    score_table.append((score, name))

score_table.sort(reverse=True)
for i in range(3):
    print(f'{score_table[i][0]} : {score_table[i][1]}')


# Задание 2:
# ввести имя игрока. К задаче выше найти место в рейтинге этого игрока

for i in range(len(score_table)):
    score_table[i] = (score_table[i][1], i)
score_table.sort()
name = input('name > ')
s = 0
e = len(score_table) - 1
m = len(score_table) // 2
while score_table[m][0] != name and s <= e:
    if name > score_table[m][0]:
        s = m + 1
    else:
        e = m - 1
    m = (s + e) // 2
if s > e:
    print('Нет такого игрока')
else:
    print(score_table[m])

# Алгоритмы

# Можно хорошо знать язык программирования, но без знаний алгоритмов обойтись тяжело.
# Алгоритмы позволяют писать быстрые и качественные программы для обработки данных.
# В этом уроке мы познакомимся с базовыми понятиями оценки алгоритмов и реализуем алгоритм сортировки.

# Оценка алгоритмов
# Двумя самыми главными оценками алгоритмов являются оценка по памяти и по времени.
# Оценка по памяти зависит от количества выделенной памяти под переменные с изменяемым типом, такие как строки и списки.
# Оценка по времени зависит от количества циклов.

# Пример:
# Если у нас есть два списка по 20 элементов и нам нужно сравнить каждый элемент со всеми другими,
# то мы выбираем элемент 20 раз и сравниваем один элемент с 19 другими и того: 20 * 19 или если округлять 20^2

# Математически оценка записывается как O(n) (О большое от n).
# Символ O - говорит что мы берем максимально большое значение.
# При оценке используется "специальные вычисления", мы можем отбросить все численные значения, считая что размер n
# намного больше обычного числа, например O(2n) или O(5/7*n) это такая же сложность как и при O(n), O(3) = O(1) и т.д.

# Рассмотрим пример на простой сортировке пузырьком.
# Сортировка пузырьком так называется, потому что каждый элемент с новым циклом как будто бы "всплывает" на свое место,
# как пузырьки в воде.

# Создадим наш список из чисел, который будем сортировать:

list_of_nums = [31, 40, 75, 10, 88, 61, 40, 26, 46, 5, 1, 34, 70, 39, 24, 30, 95, 94, 25, 81]
print(list_of_nums)
# Этот список содержит положительные целые числа, в случайном порядке.


# Объявим нашу функцию сортировку, на вход она будет получать список чисел, которые надо отсортировать
def bubble_sort(nums):
    for i in range(len(nums)):  # этот цикл отвечает за выбор элемента которые мы будем сравнивать с другими значениями
        for j in range(len(nums)):  # в этом цикле мы перебираем все значения для сравнения
            if nums[i] < nums[j]:  # Этап сравнения элементов
                nums[i], nums[j] = nums[j], nums[i]  # Если i-ый элемент больше j-го, то меняем их местами


sorted_nums = list_of_nums.copy()
bubble_sort(sorted_nums)
print('Сортировка пузырьком:')
print(sorted_nums)

# Оценка алгоритма пузырьком:
# По времени: у нас 2 цикла for один внутри другого, считая что размер списка n - элементов, получаем O(n*n) = O(n^2).
# По памяти: алгоритм сортировки не создает дополнительные списки для хранения элементов, по этому память всегда
# выделяется одинаковая, то есть O(1).

# Алгоритм сортировки пузырьком эффективен по памяти, но его скорость одна из самых медленных.


# Еще один пример - сортировка вставками:
def insertion_sort(nums):
    for i in range(1, len(nums)):
        element = nums[i]  # В element сохранили значение nums[i]
        # Начиная с элемента nums[i - 1]
        j = i - 1
        # все элементы, которые больше element
        while j >= 0 and nums[j] > element:
            # сдвигаем вправо на 1
            nums[j + 1] = nums[j]
            j -= 1
            # На свободное место записываем element
        nums[j + 1] = element


sorted_nums = list_of_nums.copy()
insertion_sort(sorted_nums)
print('Сортировка вставками:')
print(sorted_nums)
# Оценим сложность алгоритма сортировки вставками:
# По времени: с каждой итерацией количество перемещений увеличивается на 1:
# 1 + 2 + ... + (n - 1) + n = n(n+1)/2, и если отбросить числа: O(n^2).
# По памяти: алгоритм так же не создает новые списки для хранения элементов, поэтому O(1).


# В качестве примера часто используемой сортировки рассмотрим быструю сортировку слиянием:
def merge_sort(nums):
    if len(nums) > 1:  # если в списке не более одного элемента, то считаем список отсортированным
        left_part = nums[:len(nums) // 2]  # Разделим список на левую и правую половину
        right_part = nums[len(nums) // 2:]
        merge_sort(left_part)  # и выполним сортировку для левой и правой части
        merge_sort(right_part)
        i = j = k = 0  # заведем счетчики индекса для левого и правого списка, а также счетчик индекса для всего списка
        # пока есть элементы в левой и правой части, вставляем их в наш список в порядке возрастания
        while i < len(left_part) and j < len(right_part):
            if left_part[i] <= right_part[j]:
                nums[k] = left_part[i]
                i += 1
            else:
                nums[k] = right_part[j]
                j += 1
            k += 1
        # дойдя до этой строчки либо левая, либо правая половина списка уже закончилась,
        # остается только просто добавить элементы в конец списка
        while i < len(left_part):  # если остались элементы в левой половине
            nums[k] = left_part[i]
            i += 1
            k += 1
        while j < len(right_part):  # если остались элементы в правой половине
            nums[k] = right_part[j]
            j += 1
            k += 1


sorted_nums = list_of_nums.copy()
merge_sort(sorted_nums)
print('Сортировка слиянием:')
print(sorted_nums)
# Оценим сложность алгоритма сортировки слиянием:
# По времени: каждый раз мы разделяем список пополам, что соответствует функции O(log n) и
# за один проход по всем элементам в каждой половине добавляем его в наш список за O(n), и того O(n log n)
# По памяти: этот алгоритм уже сознают копии левой и правой части, соответственно выделяется O(n) памяти

# Python имеет встроенный алгоритм сортировки, работающий похожим способом как merge_sort.
# Что бы использовать встроенную сортировку используются два похожих метода:

# 1. метод списков sort():
sorted_nums = list_of_nums.copy()
result_of_sort = sorted_nums.sort()
print('Сортировка с помощью sort:')
print(sorted_nums)
print('результат сортировки:')
print(result_of_sort)
# Как видно из примера, метод sort ничего не возвращает, а сортирует элементы в самом списке (модифицирует его)

# 2. функция sorted():
sorted_nums = list_of_nums.copy()
result_of_sort = sorted(sorted_nums)
print('Сортировка с помощью sorted:')
print(sorted_nums)
print('результат сортировки:')
print(result_of_sort)
# список sorted_nums не изменился, а вот функция уже вернула новый список с отсортированными значениями

# У sort и sorted есть два дополнительных параметра, reverse и key.
# reverse - сортирует список в обратном порядке, по умолчанию сортировка идет от меньшего к большему (по возрастанию)
# key - функция по результату работы которой происходит сортировка
sorted_nums = list_of_nums.copy()
sorted_nums.sort(reverse=True, key=lambda x: x % 10)
print('Сортировка с помощью sort, по убыванию последней цифры:')
print(sorted_nums)

# или

sorted_nums = list_of_nums.copy()
result_of_sort = sorted(sorted_nums, reverse=True, key=lambda x: x % 10)
print('Сортировка с помощью sort, по убыванию последней цифры:')
print(result_of_sort)

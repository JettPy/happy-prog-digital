# регулярные выражения (regular expression)

# Регулярные выражения - это строки, которые описывают некий шаблон текста.
# Регулярные выражения применяются для поиска или замены текста

# Основные правила регулярных выражений:

# 1) скобки [] обозначают набор символов:
# 1.1) [abcdef12345] - прямое перечисление всех символов
# 1.2) [a-f1-5] - перечисление интервалов символов
# 1.3) [^a-f1-5] и [^abcdef12345] - перечисление интервалов исключенных символов, т.е. все кроме них (инверсия)
# Пример: [abcdef12345] или [a-f1-5] - шаблон, под который подходят буквы от a до f и цифры от 1 до 5.

# 2) Символы \w и \W - первый означает буквенный, цифровой символ или знак подчёркивания,
# второй НЕ буквенный, цифровой символ или знак
# \w аналогичен записи - [a-zA-Z0-9-]

# 3) Символы \d и \D - цифровой символ и любой не цифровой аналогично

# 4) Символы \s и \S - пробельный (пробел, табуляция, перенос строки и т.д.) и не пробельный символ

# 5) Символ \ и т.п. записывается как \\ (перед ними ставится дополнительный обратный слэш), для экранирования

# 6) Символ ^ в начале и $ в конце означают начало и конец строки соответственно.

# 7) . (точка) - один любой символ

# Квантификация (количество повторений)

# 8) * - нуль или любое количество повторений

# 9) + - одно или любое количество повторений

# 10) ? - нуль или один символ (символ либо есть, либо его нет)

# 11.1) {n} - символ повторяется n раз
# 11.2) {m,n} - символ повторяется от m до n раз
# 11.3) {,n} - символ повторяется до n раз
# 11.4) {m,} - символ повторяется от m раз

# Это основные правила которые надо знать про регулярные выражения, но есть и многие другие правила и методы

# Для работы с регулярными выражениями в python используется библиотека re:
import re

# Рассмотрим некоторые полезные методы:
# 1) search(<регулярное выражение>, <строка где искать>) - ищет первую подходящую под шаблон подстроку.
# Возвращает объект Match
str1 = "Hello 123456, world12345!"
match = re.search(r"\d+", str1)  # передаем шаблон, состоящий из 1 или нескольких цифр
print(match.span(), match.string, match.group(), sep='\n')
# match.span() - (6, 12) - индексы начала и конца найденной подстроки
# match.string - Hello 123456, world12345! - строка, в которой осуществляется поиск соответствий с регулярным выражением
# match.group() - группа найденных подстрок (больше одного элемента если больше одного регулярного выражения)

# 2) findall(<регулярное выражение>, <строка где искать>) - находит все подходящие под шаблон строки
str2 = "Hello 123456, world12345!"
match = re.findall(r"\d+", str2)
print(match)  # Вывод: ['123456', '12345']

# 3) split(<регулярное выражение>, <строка где искать>) - разделяет строку по регулярному выражению
str3 = "Hello 123456, world12345!"
match = re.split(r"\d+", str3)
print(match)  # Вывод: ['Hello ', ', world', '!']

# 4) sub(<регулярное выражение>, <новая подстрока>, <строка где искать>) - заменяет подстроки, подходящие под шаблон на
# переданную новую подстроку
str4 = "Hello 123456, world12345!"
match = re.sub(r"\d+", "00", str4)
print(match)  # Вывод: Hello 00, world00!


# Создадим бота, который будет по запросу пользователя искать видео на Youtube и отправлять ссылки:
import telebot
import os
import dotenv
import urllib  # urllib - стандартная библиотека для работы с URL адресами
import requests as req  # requests - библиотека для отправки и приема запросов через интернет

dotenv.load_dotenv()
API_TOKEN = os.getenv('API_TOKEN')
bot = telebot.TeleBot(API_TOKEN)

# Сохраним основную часть url адреса для запроса видео на Youtube
url = 'http://www.youtube.com/results?'

# Запишем регулярное выражение для выделения идентификаторов из полученной информации от запроса
regexp = '(?<=/watch\?v=)[\w-]{11}'
# compile(<регулярное выражение>) – создает объект из регулярного выражения. Применяется, если один и тот же поисковый
# шаблон используется в коде несколько раз
# <паттерн> = re.compile(<регулярное выражение>)
pattern = re.compile(regexp)


# Создадим обработчик текстовых сообщений
@bot.message_handler(content_types=['text'])
def get_text_message(message):
    # Используя библиотеку urllib конвертируем текст сообщение в url атрибут для поиска
    query_string = urllib.parse.urlencode({"search_query": message.text})
    # Далее выполняем запрос по сохраненному url и ранее сохраненному атрибуту query_string
    res = req.get(url + query_string)
    # res.ok - проверяет, успешно ли выполнен запрос
    if res.ok:
        # Если запрос выполнен успешно, то res.text будет содержать html страницу.
        # Используя ранее созданный шаблон, найдем все идентификаторы видео.
        video_ids = pattern.findall(res.text)
        # Так как есть шанс, что идентификаторы видео могут встретиться несколько раз, заведем множество, для записи
        # уже рассмотренных ссылок на видео
        unic_ids = set()
        for video_id in video_ids:
            # Что бы вывод не был чрезмерно объемным, будем выводить только первые 5 ссылок.
            if len(unic_ids) == 5:
                break
            elif video_id not in unic_ids:  # Если ссылка с таким идентификатором еще не было
                unic_ids.add(video_id)  # то сохраняем этот id и отправляем ссылку для просмотра видео.
                answer = 'http://www.youtube.com/watch?v=' + video_id
                bot.send_message(message.chat.id, answer)


bot.infinity_polling()

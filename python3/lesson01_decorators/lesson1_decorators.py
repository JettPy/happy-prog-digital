# Декораторы

# Рассмотрим получше функции.
# Для начала создадим простую функцию:
def some_func():
    print("Это функция")


# Обычно мы вызывали функции так:
some_func()
# Вывод:
# Это функция

# Интересно, что функции можно передавать в функцию type, что бы узнать ее тип:
print(type(some_func))  # Вывод: <class 'function'>

# Таким образом, мы видим что у функции есть собственный тип - function
# Благодаря этому мы можем присвоить объявленную функцию в переменную:
a = some_func  # Скобки () - вызов функции, без них мы просто сохраним функцию в отдельную переменную.
# И теперь мы подобным образом можем вызвать функцию из переменной:
a()
# Вывод:
# Это функция


# Поскольку мы можем сохранять функцию в переменную, то мы так же можем передавать функцию как аргумент другой функции:
def decorator_in_place(function):
    print("Эта часть будет выполнена до вызова функции")
    function()
    print("Эта часть будет выполнена после вызова функции")


# Теперь можно сделать так:
decorator_in_place(some_func)
# Вывод:
# Эта часть будет выполнена до вызова функции
# Это функция
# Эта часть будет выполнена после вызова функции

# Это и есть принцип работы декораторов - мы можем выполнять различные действия перед и после вызова функции

# Часто бывает что нам не надо сразу выполнять переданную функцию сразу.
# Для этого тело функции оборачивает в "обертку" (wrapper) и возвращают ее:
def decorator(function):
    def wrapper():
        print("Эта часть будет выполнена до вызова функции")
        function()
        print("Эта часть будет выполнена после вызова функции")
    return wrapper


# После этого функцию можно будет вызвать тогда, когда нам понадобится:
b = decorator(some_func)  # Вызова не было
b()
# Вывод:
# Эта часть будет выполнена до вызова функции
# Это функция
# Эта часть будет выполнена после вызова функции

# Задание 1:
# Создать сэндвич с использованием декораторов.


# Обертка для булочек
def bread(func):
    def wrapper():
        print("/---------\\")
        func()
        print("\\--------/")
    return wrapper


# Обертка для овощей
def ingredients(func):
    def wrapper():
        print("#помидоры#")
        func()
        print("~~~салат~~~")
    return wrapper


# Наш сэндвич с ветчиной
def sandwich(food='--ветчина--'):
    print(food)


# Теперь запишем всю вложенную конструкцию и сразу вызовем ее добавив в конец ():
bread(ingredients(sandwich))()
# Вывод:
# /---------\
# #помидоры#
# --ветчина--
# ~~~салат~~~
# \--------/


# Как видно из примера с увеличением количества декораторов конструкция вызова достаточно сильно разрастается.
# Для решения этой проблемы в синтаксисе питона можно использовать значок @:
@bread
@ingredients
def sandwich_2(food='--ветчина--'):
    print(food)


# Мы заранее обернули функцию в два декоратора по очереди. Теперь можно вызвать функцию так:
sandwich_2()
# Вывод:
# /---------\
# #помидоры#
# --ветчина--
# ~~~салат~~~
# \--------/


# Но есть одна проблема - мы не сможем передавать аргументы в такой декоратор.
# Что бы сделать такую возможность нужно добавить такие аргументы как *args, **kwargs:
def bread_args(func):
    def wrapper(*args, **kwargs):  # args - аргументы функции по типу: f(1, 2)
        print("/---------\\")      # kwargs - именованные аргументы по типу: f(a=1, b=2)
        func(*args, **kwargs)
        print("\\--------/")
    return wrapper


def ingredients_args(func):
    def wrapper(*args, **kwargs):
        print("#помидоры#")
        func(*args, **kwargs)
        print("~~~салат~~~")
    return wrapper

@bread_args
@ingredients_args
def sandwich_args(food='--ветчина--'):
    print(food)


sandwich_args('**курица**')
# Вывод:
# /---------\
# #помидоры#
# **курица**
# ~~~салат~~~
# \--------/
